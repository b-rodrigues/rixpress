% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rxp_populate.R
\name{rxp_populate}
\alias{rxp_populate}
\title{Generate Nix Pipeline Code without Building}
\usage{
rxp_populate(derivs, project_path = ".", py_imports = NULL)
}
\arguments{
\item{derivs}{A list of derivation objects, where each object is a list of
five elements:
\itemize{
\item \verb{$name}, character, name of the derivation
\item \verb{$snippet}, character, the nix code snippet to build this derivation
\item \verb{$type}, character, can be R, Python or Quarto
\item \verb{$additional_files}, character vector of paths to files to make
available to build sandbox
\item \verb{$nix_env}, character, path to Nix environment to build this derivation
}
A single deriv is the output of \code{rxp_r()}, \code{rxp_qmd()} or \code{rxp_py()}
function.}

\item{project_path}{Path to root of project, defaults to ".".}

\item{py_imports}{Named list for Python import adjustments. Names should be
the old import statements to replace, and values should be the new import
statements. For example: \code{list("import pillow" = "from PIL import Image", "import numpy" = "import numpy as np")}. If NULL (default), no import
adjustments are made.}
}
\value{
Nothing, writes a file called \code{pipeline.nix} with the Nix code to
build the pipeline.
}
\description{
This function generates a \code{pipeline.nix} file based on a list of derivation
objects but does not build the pipeline. It is equivalent to calling
\code{rixpress(build = FALSE)} but with additional support for inline Python
import adjustments. After generating the pipeline, you can build it using
\code{rxp_make()}.
}
\details{
This function provides a two-step workflow that is particularly useful for
Python projects:
\enumerate{
\item \code{rxp_populate()} - Generate the pipeline and optionally adjust Python imports
\item \code{rxp_make()} - Build the pipeline
}

The \code{py_imports} parameter allows you to make common Python import adjustments
inline, without needing to call \code{adjust_import()} separately. This is especially
useful for packages like \code{pillow} (which needs \code{from PIL import Image} instead
of \code{import pillow}) or when you want to use common aliases like \code{import numpy as np}.
}
\examples{
\dontrun{
# Basic usage without import adjustments
d1 <- rxp_r(mtcars_am, filter(mtcars, am == 1))
d2 <- rxp_r(mtcars_head, head(mtcars_am))
list_derivs <- list(d1, d2)

rxp_populate(derivs = list_derivs)
rxp_make()

# Python project with import adjustments
derivs <- list(
  rxp_py(data_load, "df = pd.read_csv('data.csv')"),
  rxp_py(image_proc, "img = Image.open('photo.jpg')")
)

rxp_populate(
  derivs = derivs,
  py_imports = list(
    "import pandas" = "import pandas as pd",
    "import pillow" = "from PIL import Image"
  )
)
rxp_make()
}
}
\seealso{
Other pipeline functions: 
\code{\link{rixpress}()},
\code{\link{rxp_make}()}
}