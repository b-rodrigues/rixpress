% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/derivs.R
\name{rxp_r}
\alias{rxp_r}
\title{Create a Nix expression running an R function}
\usage{
rxp_r(
  name,
  expr,
  additional_files = "",
  user_functions = "",
  nix_env = "default.nix",
  serialize_function = NULL,
  unserialize_function = NULL,
  env_var = NULL,
  build = TRUE
)
}
\arguments{
\item{name}{Symbol, name of the derivation.}

\item{expr}{R code to generate the expression.}

\item{additional_files}{Character vector, additional files to include
during the build process. For example, if a function expects a certain
file to be available, this is where you should include it.}

\item{user_functions}{Character vector, user-defined functions to include.
This should be a script (or scripts) containing user-defined functions
to include during the build process for this derivation. It is recommended
to use one script per function, and only include the required script(s) in
the derivation.}

\item{nix_env}{Character, path to the Nix environment file, default is
"default.nix".}

\item{serialize_function}{Function, defaults to NULL. A function used to
serialize objects for transfer between derivations. It must accept two
arguments: the object to serialize (first), and the target file path
(second). If your function has a different signature, wrap it to match this
interface. By default, \code{saveRDS()} is used, but this may yield unexpected
results, especially for complex objects like machine learning models. For
instance, for \code{{keras}} models, use \code{keras::save_model_hdf5()} to capture
the full model (architecture, weights, training config, optimiser state,
etc.).}

\item{unserialize_function}{Function, defaults to NULL. A function used to
unserialize objects transferred between derivations. By default,
\code{readRDS()} is used, but this may produce unexpected results with complex
objects like machine learning models. For example, if the parent derivation
used \code{keras::save_model_hdf5()} to serialize a model, this derivation
should use \code{keras::load_model_hdf5()} to load it correctly.}

\item{env_var}{Character vector, defaults to NULL. A named vector of
environment variables to set before running the R script, e.g.,
\verb{c("CMDSTAN" = "$\{defaultPkgs.cmdstan\}/opt/cmdstan)"}.
Each entry will be added as an export statement in the build phase.}

\item{build}{Logical, defaults to TRUE. If TRUE, the derivation will be built
when the pipeline runs. If FALSE, the derivation definition is created but
the build is skipped.}
}
\value{
An object of class derivation which inherits from lists.
}
\description{
Create a Nix expression running an R function
}
\details{
At a basic level, \code{rxp_r(mtcars_am, filter(mtcars, am == 1))} is
equivalent to \code{mtcars_am <- filter(mtcars, am == 1)}. \code{rxp_r()} generates the
required Nix boilerplate to output a so-called "derivation" in Nix jargon.
A Nix derivation is a recipe that defines how to create an output (in this
case \code{mtcars_am}) including its dependencies, build steps, and output
paths.
}
\examples{
\dontrun{
  # Basic usage
  rxp_r(name = filtered_mtcars, expr = filter(mtcars, am == 1))

  # Skip building this derivation
  rxp_r(
    name = turtles,
    expr = occurrence(species, geometry = atlantic),
    build = FALSE
  )

  # Serialize object using qs
  rxp_r(
   name = filtered_mtcars,
   expr = filter(mtcars, am == 1),
   serialize_function = qs::qsave
  )
  # Unerialize using qs::qread in the next derivation
  rxp_r(
   name = mtcars_mpg,
   expr = select(filtered_mtcars, mpg),
   unserialize_function = qs::qread
  )
}
}
\seealso{
Other derivations: 
\code{\link{rxp_jl}()},
\code{\link{rxp_jl_file}()},
\code{\link{rxp_py}()},
\code{\link{rxp_py_file}()},
\code{\link{rxp_qmd}()},
\code{\link{rxp_r_file}()},
\code{\link{rxp_rmd}()}
}
\concept{derivations}
