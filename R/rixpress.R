#' Generate Nix Pipeline Code with a Generic Default Target
#'
#' This function generates a `pipeline.nix` file based on a list of derivation
#' objects. Each derivation defines a build step, and `rixpress()` chains these
#' steps and handles the serialization and conversion of Python objects into R
#' objects (or vice-versa). Derivations are created with `rxp_r()`, `rxp_py()`
#' and so on. By default, the pipeline is also immediately after being generated,
#' but the build process can be postponed by setting `build` to FALSE. In this case,
#' the pipeline can then be built using `rxp_make()`.
#'
#' @family pipeline functions
#' @param derivs A list of derivation objects, where each object is a list of
#'   five elements:
#'     - `$name`, character, name of the derivation
#'     - `$snippet`, character, the nix code snippet to build this derivation
#'     - `$type`, character, can be R, Python or Quarto
#'     - `$additional_files`, character vector of paths to files to make
#'        available to build sandbox
#'     - `$nix_env`, character, path to Nix environment to build this derivation
#'   A single deriv is the output of `rxp_r()`, `rxp_qmd()` or `rxp_py()`
#'   function.
#'
#' @param project_path Path to root of project, defaults to ".".
#'
#' @param build Logical, defaults to TRUE. Should the pipeline get built right
#'   after being generated? If FALSE, you can build the pipeline later using
#'   `rixpress()`.
#'
#' @param ... Further arguments passed down to methods. Use `max-jobs` and
#'   `cores` to set parallelism during build. See the documentation of
#'   `rxp_make()` for more details.
#'
#' @return Nothing, writes a file called `pipeline.nix` with the Nix code to
#'   build the pipeline.
#'
#' @details
#' The generated `pipeline.nix` expression includes:
#' - the required imports of environments, typically `default.nix` files generated by
#'   the `rix` package;
#' - correct handling of interdependencies of the different derivations;
#' - serialization and deserialization of both R and Python objects, and conversion
#'   between them when objects are passed from one language to another;
#' - correct loading of R and Python packages, or extra functions needed to build
#'   specific targets
#'
#' In some cases, due to the automatic handling of Python packages, users might
#' want to change import statements. By default if, say, `pandas` is needed to
#' build a derivation, it will be imported with `import pandas`. However, Python
#' programmers typically use `import pandas as pd`. To change the automatic
#' import statements, please refer to `adjust_import()`.
#'
#' @examples
#' \dontrun{
#' # Create derivation objects
#' d1 <- rxp_r(mtcars_am, filter(mtcars, am == 1))
#' d2 <- rxp_r(mtcars_head, head(mtcars_am))
#' list_derivs <- list(d1, d2)
#'
#' # Generate the pipeline code
#' rixpress(derivs = list_derivs, project_path = ".", build = TRUE)
#'
#' }
#' @export
rixpress <- function(derivs, project_path = ".", build = TRUE, ...) {
  generate_dag(
    derivs,
    output_file = file.path(project_path, "_rixpress", "dag.json")
  )

  # Need to combine nix envs and additional files into a
  # list of two elements, "nix_env" and "additional_files"
  # which list all the unique combinations
  nix_expressions_and_additional_files <- lapply(
    derivs,
    function(d)
      list(
        "nix_env" = d$nix_env,
        "additional_files" = d$additional_files,
        "type" = d$type
      )
  )
  # Drop quarto objects, as these are handled separately
  nix_expressions_and_additional_files <- lapply(derivs, function(d) {
    if (d$type == "rxp_qmd" || d$type == "rxp_rmd") {
      d$additional_files <- ""
    }
    list(
      nix_env = d$nix_env,
      additional_files = d$additional_files,
      type = d$type
    )
  })

  flat_list <- list(
    nix_env = sapply(
      X = nix_expressions_and_additional_files,
      FUN = `[[`,
      "nix_env",
      USE.NAMES = FALSE
    ),
    additional_files = sapply(
      X = nix_expressions_and_additional_files,
      FUN = `[[`,
      "additional_files",
      USE.NAMES = FALSE
    )
  )

  nix_env_all <- flat_list$nix_env
  add_files_all <- flat_list$additional_files

  unique_env <- unique(nix_env_all)

  additional_files_combined <- lapply(
    unique_env,
    function(env) {
      idx <- which(nix_env_all == env)
      files <- unlist(add_files_all[idx])
      files <- files[!is.na(files) & files != ""]
      if (length(files) == 0) return("")
      unique(files)
    }
  )

  result <- list(
    nix_env = unique_env,
    additional_files = additional_files_combined
  )

  suppressWarnings(
    for (i in seq_along(result$nix_env)) {
      generate_libraries_from_nix(
        result$nix_env[i],
        result$additional_files[[i]],
        project_path = project_path
      )
    }
  )

  # Finalize pipeline
  flat_pipeline <- gen_flat_pipeline(derivs)

  pipeline <- gen_pipeline(
    dag_file = file.path(paste0(project_path, "/_rixpress/dag.json")),
    flat_pipeline = flat_pipeline
  )

  writeLines(pipeline, file.path(project_path, "pipeline.nix"))

  if (build) {
    rxp_make(...)
  }
}


#' parse_nix_envs Parses the nix_env element of a deriv object
#' @param derivs A list of derivation objects, where each object is a list of
#'   five elements:
#'     - `$name`, character, name of the derivation
#'     - `$snippet`, character, the nix code snippet to build this derivation
#'     - `$type`, character, can be R, Python or Quarto
#'     - `$additional_files`, character vector of paths to files to make
#'        available to build sandbox
#'     - `$nix_env`, character, path to Nix environment to build this derivation
#'   Typically, these objects are created by a function like `rxp_r`.
#' @noRd
parse_nix_envs <- function(derivs) {
  # Add required elements
  # base name of libraries file
  derivs <- lapply(
    derivs,
    function(d) {
      d$base_name <- sub(
        "_nix$",
        "",
        gsub("[^a-zA-Z0-9]", "_", basename(d$nix_env))
      )
      d
    }
  )
  # path to libraries file
  derivs <- lapply(
    derivs,
    function(d) {
      d$library <- list.files("_rixpress", pattern = d$base_name)
      d$library_in_sandbox <- gsub(paste0(d$base_name, "_"), "", d$library)
      list(
        "nix_env" = d$nix_env,
        "base_name" = d$base_name,
        "library" = d$library,
        "library_in_sandbox" = d$library_in_sandbox
      )
    }
  )

  derivs <- unique(derivs)

  generate_configurePhase <- function(d) {
    # Compute the configure_phases_str
    configure_phases_str <- paste0(
      d$base_name,
      "ConfigurePhase = ''\n    ",
      paste0(
        "cp ${./_rixpress/",
        unlist(d$library),
        "} ",
        unlist(d$library_in_sandbox),
        collapse = "\n    "
      ),
      "\n    mkdir -p $out\n  ",
      "'';\n  "
    )

    # Create the individual lines
    lines <- c(
      paste0(d$base_name, " = import ./", d$nix_env, ";"),
      paste0(d$base_name, "Pkgs = ", d$base_name, ".pkgs;"),
      paste0(d$base_name, "Shell = ", d$base_name, ".shell;"),
      paste0(d$base_name, "BuildInputs = ", d$base_name, "Shell.buildInputs;"),
      configure_phases_str
    )

    # Combine all lines into a single string with newline separators
    paste(lines, collapse = "\n  ")
  }

  nix_lines <- character(0)
  for (d in seq_along(derivs)) {
    current_lines <- generate_configurePhase(derivs[[d]])
    nix_lines <- c(nix_lines, current_lines)
  }

  paste(nix_lines, collapse = "\n\n  ")
}

#' gen_flat_pipeline Internal function used to generate most of the boilerplate in pipeline.nix
#' @param derivs A list of derivation objects, where each object is a list of
#'   five elements:
#'     - `$name`, character, name of the derivation
#'     - `$snippet`, character, the nix code snippet to build this derivation
#'     - `$type`, character, can be R, Python or Quarto
#'     - `$additional_files`, character vector of paths to files to make
#'        available to build sandbox
#'     - `$nix_env`, character, path to Nix environment to build this derivation
#'   A single deriv is the output of `rxp_r()`, `rxp_qmd()` or `rxp_py()`
#'   function.
#' @noRd
gen_flat_pipeline <- function(derivs) {
  derivation_texts <- vapply(
    derivs,
    function(d) d$snippet,
    FUN.VALUE = character(1)
  )
  derivations_code <- paste(derivation_texts, collapse = "\n\n")

  deriv_names <- vapply(derivs, function(d) d$name, character(1))
  names_line <- paste(deriv_names, collapse = " ")

  nix_envs <- parse_nix_envs(derivs)

  # Determine required functions
  types <- vapply(derivs, function(d) d$type, character(1))
  need_r <- get_need_r(types)
  need_py <- get_need_py(types)

  # Build function definitions
  function_defs <- ""
  if (need_r) {
    function_defs <- paste0(
      function_defs,
      "\n  # Function to create R derivations
  makeRDerivation = { name, buildInputs, configurePhase, buildPhase, src ? null }:
    defaultPkgs.stdenv.mkDerivation {
      inherit name src;
      dontUnpack = true;
      inherit buildInputs configurePhase buildPhase;
      installPhase = ''
        cp ${name} $out/
      '';
    };"
    )
  }
  if (need_py) {
    function_defs <- paste0(
      function_defs,
      "\n  # Function to create Python derivations
  makePyDerivation = { name, buildInputs, configurePhase, buildPhase, src ? null }:
    let
      pickleFile = \"${name}\";
    in
      defaultPkgs.stdenv.mkDerivation {
        inherit name src;
        dontUnpack = true;
        buildInputs = buildInputs;
        inherit configurePhase buildPhase;
        installPhase = ''
          cp ${pickleFile} $out
        '';
      };"
    )
  }

  # Generate Nix code
  pipeline_nix <- sprintf(
    'let
  %s%s

  # Define all derivations
%s

  # Generic default target that builds all derivations
  allDerivations = defaultPkgs.symlinkJoin {
    name = "all-derivations";
    paths = with builtins; attrValues { inherit %s; };
  };

in
{
  inherit %s;
  default = allDerivations;
}
',
    nix_envs,
    function_defs,
    paste0("  ", derivations_code),
    names_line,
    names_line
  )

  strsplit(pipeline_nix, split = "\n")[[1]]
}

#' gen_pipeline Internal function used to finalize a flat pipeline
#' @param dag_file A json file giving the names and relationships between derivations.
#' @param flat_pipeline A flat pipeline, output of `gen_flat_elements()`.
#' @noRd
gen_pipeline <- function(dag_file, flat_pipeline) {
  dag <- jsonlite::read_json(dag_file)
  pipeline <- flat_pipeline

  for (d in dag$derivations) {
    if (
      length(d$depends) == 0 ||
        d$type == "rxp_qmd" ||
        d$type == "rxp_rmd" ||
        d$type == "rxp_py2r" ||
        d$type == "rxp_r2py"
    )
      next

    deriv_name <- as.character(d$deriv_name[1])
    deps <- d$depends
    type <- d$type[1]
    unserialize_function <- d$unserialize_function

    # Set parameters based on derivation type
    if (type == "rxp_r") {
      maker <- "makeRDerivation"
      script_cmd <- "Rscript -e \""
      load_line <- function(dep, indent, unserialize_function) {
        paste0(
          indent,
          dep,
          " <- ",
          unserialize_function,
          "('${",
          dep,
          "}/",
          dep,
          "')"
        )
      }
    } else if (type == "rxp_py") {
      maker <- "makePyDerivation"
      script_cmd <- "python -c \""
      load_line <- function(dep, indent, unserialize_function) {
        path <- paste0("${", dep, "}/", dep)
        if (unserialize_function == "pickle.load") {
          paste0(
            "with open('",
            path,
            "', 'rb') as f: ",
            dep,
            " = pickle.load(f)"
          )
        } else {
          paste0(
            dep,
            " = ",
            unserialize_function,
            "('",
            path,
            "')"
          )
        }
      }
    } else {
      warning("Unsupported type for derivation ", deriv_name)
      next
    }

    # Locate the derivation block
    pattern <- paste0("^\\s*", deriv_name, " = ", maker, " \\{")
    start_idx <- grep(pattern, pipeline)
    if (!length(start_idx)) {
      warning("Derivation ", deriv_name, " not found")
      next
    }
    start_idx <- start_idx[1]

    # Find the end of the block
    end_candidates <- grep("^\\s*};", pipeline)
    block_end_idx <- end_candidates[end_candidates > start_idx][1]
    if (is.na(block_end_idx)) {
      warning("Block end for ", deriv_name, " not found")
      next
    }

    block <- pipeline[start_idx:block_end_idx]
    bp_idx <- grep("buildPhase = ''", block)
    if (!length(bp_idx)) {
      warning("buildPhase not found for ", deriv_name)
      next
    }
    build_phase_idx <- start_idx + bp_idx[1] - 1

    sub_block <- block[bp_idx[1]:length(block)]
    script_idx <- grep(script_cmd, sub_block, fixed = TRUE)
    if (!length(script_idx)) {
      warning("Script command not found in buildPhase for ", deriv_name)
      next
    }
    script_idx <- build_phase_idx + script_idx[1]

    # Determine indentation for R scripts, none for Python
    indent <- if (type == "rxp_r") {
      if (script_idx + 1 <= length(pipeline)) {
        sub("^([[:space:]]*).*", "\\1", pipeline[script_idx + 1])
      } else {
        "      "
      }
    } else {
      ""
    }

    load_lines <- vapply(
      deps,
      load_line,
      indent,
      unserialize_function,
      FUN.VALUE = character(1)
    )
    pipeline <- append(pipeline, load_lines, after = build_phase_idx + 2)
  }

  pipeline
}

#' Generate an R or Py script with library calls from a default.nix file
#'
#' @param nix_env Nix environment where the derivation runs
#' @param additional_files Character vector, additional files to include. These
#'   are the files that contain custom functions required for this derivation.
#' @param project_path Path to root of project, typically "."
#' @return An script to load the libraries inside of derivations.
#' @noRd
generate_libraries_from_nix <- function(
  nix_env,
  additional_files = "",
  project_path
) {
  generate_r_libraries_from_nix(
    nix_env,
    additional_files,
    project_path
  )
  generate_py_libraries_from_nix(
    nix_env,
    additional_files,
    project_path
  )
}


#' @noRd
get_need_r <- function(types) {
  any(
    types %in%
      c("rxp_r", "rxp_r_file", "rxp_rmd", "rxp_qmd", "rxp_py2r", "rxp_r2py")
  )
}

#' @noRd
get_need_py <- function(types) {
  any(types %in% c("rxp_py", "rxp_py_file"))
}
